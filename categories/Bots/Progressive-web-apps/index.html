
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Meulta&#39;s blog">
    <title>Category: Progressive web apps - Meulta&#39;s blog</title>
    <meta name="author" content="Etienne Margraff">
    
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Meulta&#39;s blog">
<meta property="og:url" content="http://yoursite.com/categories/Bots/Progressive-web-apps/index.html">
<meta property="og:site_name" content="Meulta&#39;s blog">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Meulta&#39;s blog">
<meta name="twitter:creator" content="@http:&#x2F;&#x2F;twitter.com&#x2F;meulta">
    
    
        
    
    
        <meta property="og:image" content="http://yoursite.com/assets/images/avatar.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-c4ozcsklz4kht2pebhp44xorvyverh23toayhn7i6ubrpyedak24hv1v0hyd.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Meulta&#39;s blog</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture">
                </a>
                <h4 class="sidebar-profile-name">Etienne Margraff</h4>
                
                    <h5 class="sidebar-profile-bio"><p>I write code and love working with web, AR, VR and Spatial Computing</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="Home">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="Categories">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="Tags">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" title="Archives">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" title="About">
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/meulta" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://twitter.com/meulta" target="_blank" rel="noopener" title="Twitter">
                    
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://www.linkedin.com/in/etima/" target="_blank" rel="noopener" title="LinkedIn">
                    
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/atom.xml" title="RSS">
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a class="link-unstyled" href="/2017/04/17/bot-framework-web-chat-and-push-notifications/">
                            Bot framework, web chat and push notifications
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2017-04-17T16:18:26-07:00">
	
		    Apr 17, 2017
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Bots/">Bots</a>, <a class="category-link" href="/categories/Bots/Progressive-web-apps/">Progressive web apps</a>, <a class="category-link" href="/categories/Bots/Progressive-web-apps/Web/">Web</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p><em>This blog article is explaining how to setup web push notifications on a bot framework web chat control. For this, we will use service workers and VAPID. All the code shown here is available in this <a href="https://github.com/meulta/webchat-pushnotifications" target="_blank" rel="noopener">Github repository</a> containing the full version of it. You can also try <a href="https://webchatpush.azurewebsites.net/web/index.html" target="_blank" rel="noopener">this live sample</a> or watch the video below.</em></p>
<div style="width: 640px;" class="wp-video"><br>  <video class="wp-video-shortcode" id="video-255-6" width="640" height="480" loop="1" autoplay="1" preload="metadata" controls="controls"><source type="video/mp4" src="/media/push-notifications.mp4"><a href="/media/push-notifications.mp4">push-notifications.mp4</a></video><br></div>

<blockquote>
<p>If you have any question about this blog article, feel free to contact me on twitter: <a href="https://twitter.com/meulta" target="_blank" rel="noopener">@meulta</a></p>
</blockquote>
<h1 id="Progressive-web-apps"><a href="#Progressive-web-apps" class="headerlink" title="Progressive web apps"></a><strong>Progressive web apps</strong></h1><p>The web is in a perpetual evolution. The advantage that apps have over it on mobile platforms is slowly fading away as more and more features are available from the browser. The web community and web browsers team like Microsoft Edge, Google Chrome and Mozilla Firefox are working on enabling the next wave of native-like web experiences, where web content can have the essential capabilities and user experience of native desktop or mobile apps. These web apps can start up instantly, can run in the background and have additional APIs available for developers. We call them: <a href="https://medium.com/web-on-the-edge/progressive-web-apps-on-windows-8d8eb68d524e" target="_blank" rel="noopener">Progressive Web Apps</a> (PWAs).</p>
<p>PWAs are safe, connectivity independent, installable and responsive websites. There is a great chance that you already used one, even without knowing it. Did you already received notifications from Facebook even if the website is not opened in your browser? It is because Facebook is starting to use some of the underlining technology in PWAs. The heart of these new technologies are <a href="https://www.w3.org/TR/service-workers/" target="_blank" rel="noopener"><strong>service workers</strong>.</a></p>
<p>Service workers are slowly being implemented in every browser to help web developers create web apps that are connectivity independent. You can see them as a proxy that goes between the local webpage and your server. It is used to handle caching, push notifications, and even temporary disconnection with background sync.</p>
<h1 id="Bot-framework-web-chat-and-the-need-of-push-notifications"><a href="#Bot-framework-web-chat-and-the-need-of-push-notifications" class="headerlink" title="Bot framework, web chat and the need of push notifications"></a><strong>Bot framework, web chat and the need of push notifications</strong></h1><p>The <a href="https://dev.botframework.com/" target="_blank" rel="noopener">Microsoft Bot Framework</a> is a platform that helps developers create a bot which works across multiple channels. You use the Node.js or C# botbuilder SDK to create the bot backend and you can almost automatically make is available on Skype, Slack, Facebook, and a lot more. The combinaison of the <a href="https://github.com/Microsoft/BotFramework-WebChat" target="_blank" rel="noopener"><strong>web chat</strong></a> and Direct Line is one of these channels. Its name is pretty explicit: it is a web chat control that you can embed in any web page. It is very useful when, for example, you want to embed a support bot chat window directly in your website. Web clients have always been inferior to native clients in one way: background.  Your native client can be granted privileges to run in the background and engage users even when the app isn’t running.  We want to provide that same functionality for the web client</p>
<p>As you might be using at least one instant messaging app on a day to day basis, you should be familiar with the fact that if someone talks to you when the app is closed or reduced you will receive a notification. You can click or tap on it to view the new message and the previous conversation. Having this is important to make the chat UI usable in the long term. It is the same if you are talking with a bot. Usually it will give you an answer pretty quickly as there is no concept of a bot being “away from keyboard” or “not connected”. This said, you might get a message from a bot which:</p>
<ul>
<li>Took some time to compute or get so did not arrive instantly</li>
<li>Is a proactive message from the bot at a random time</li>
<li>Is a human which took over the conversation and “replaced” the bot</li>
<li>Your network doesn’t allow for immediate communication</li>
</ul>
<p><strong>Push notifications</strong> help the user not missing an important message from you. By enabling them to the web client we will fix the gap between native and web clients.</p>
<h1 id="Push-notifications"><a href="#Push-notifications" class="headerlink" title="Push notifications"></a><strong>Push notifications</strong></h1><p>If you never handled push notifications in an app it is important to understand how it works.</p>
<p>When you receive a push notification from an app or a website, even if it looks like they sent it to you directly: it is not technically true. They used a <strong>push notification service</strong>. This push notification service is linked to the platform you are using. Android uses a push server and Windows another one. It is the same for push notification on a browser: Chrome has its own server, Firefox too, etc.</p>
<p>When you want to be able to send push to a client, you globally have to follow these steps:</p>
<ul>
<li><strong>Step 1</strong>: Setup an account on every platform you want to be able to send push to. The push service creates a push sender key that you will need later.</li>
<li><strong>Step 2</strong>: Subscribe a client to push: this is done and handled by the platform. You do not call directly the push server but you ask the platform to do it. For it to work and for the push server to be able to identify yourself, you have to provide the key it gave you.</li>
<li><strong>Step 3</strong>: The client get information related to the new subscription: an endpoint on the push server to call to send a new notification and keys for authentication</li>
<li><strong>Step 4</strong>: Usually, your client code then sends that to your server code to store this subscription information</li>
<li><strong>Step 5+</strong>: each time you want to send a notification to this client, you use the endpoint and keys that you got from it. The push server will then send that notification to the system which registered (a browser, a mobile, a desktop, etc.). Finally, the system displays it to the user who can see it and click on it.</li>
</ul>
<p><img class="alignnone size-full wp-image-300" src="/media/push.png" alt="" width="1896" height="1046" sizes="(max-width: 1896px) 100vw, 1896px"></p>
<p>This is identical for native apps and web apps. However, web notifications are a newer and more progressive spec.  They allow for developers to set up push without all the overhead of accounts on each platform. Your web app will still use the push server associated with each platform but you will generate your own keys. This is done by using <a href="https://tools.ietf.org/html/draft-ietf-webpush-vapid-02" target="_blank" rel="noopener">VAPID (Voluntary Application Server Identification)</a>.</p>
<p>For example, if you setup classic push notifications on chrome, you will have to give a GCM_SENDER_ID you got from a Firebase account. Using VAPID, chrome will still be using Firebase to register and get push events but you will give it your own key, which will also work with other browsers.</p>
<p>In this scenario, your server code is responsible for creating private and public keys. This is a one-time creation process. In your web client code, you use the public key to register to the push server associated with the current browser. The push service understand that you are using VAPID and you get an endpoint and an auth token. This basically only replace <strong>step 3</strong> and you can do everything else the same way.  VAPIDs represent the modern approach to push.</p>
<p>To get a deeper understanding of how VAPIDs work, you can check out any of these resources:</p>
<ul>
<li><a href="https://rossta.net/blog/using-the-web-push-api-with-vapid.html" target="_blank" rel="noopener">https://rossta.net/blog/using-the-web-push-api-with-vapid.html</a></li>
<li><a href="https://developers.google.com/web/updates/2016/07/web-push-interop-wins" target="_blank" rel="noopener">https://developers.google.com/web/updates/2016/07/web-push-interop-wins</a></li>
<li><a href="https://blog.mozilla.org/services/2016/04/04/using-vapid-with-webpush/" target="_blank" rel="noopener">https://blog.mozilla.org/services/2016/04/04/using-vapid-with-webpush/</a></li>
</ul>
<p>When you setup push on a website, you have to do it through a service worker. A service worker is a piece of code which is running side by side with your website client code. The 2 main differences are:</p>
<ul>
<li>It can run even if the website is not open in a tab</li>
<li>It is dedicated to network related work such as… push!</li>
</ul>
<p>In a push scenario, the service worker registers specifically to a “push” event. Its code will be running in the background to get and display what is pushed, and your client code will be responsible for the rest:</p>
<ul>
<li>registering the service worker JavaScript file using <strong>serviceWorker.register(…)</strong></li>
<li>registering to the push service and getting back the endpoint, key and secret for this push subscription</li>
<li>sending the endpoint, key and secret to your server code so it can send a push notification later</li>
</ul>
<p><em>Note: when you register for push in your client code, the browser will automatically ask for the user’s permission to enable push notifications.</em></p>
<p><strong>Ok, enough talking, let’s implement that!</strong></p>
<p><em>Disclaimer 1: The code I am going to talk about here is from a fully working sample which is available here:</em> <a href="https://github.com/meulta/webchat-pushnotifications" target="_blank" rel="noopener"><em>https://github.com/meulta/webchat-pushnotifications</em></a> <em>You can go and have a look at the whole implementation. I will only talk about interesting pieces here.</em> </p>
<p><em>Disclaimer 2: If you do not know anything about the Bot Framework I highly recommend reading the documentation:</em> <a href="https://docs.botframework.com/en-us/" target="_blank" rel="noopener">https://docs.botframework.com/en-us/</a></p>
<p>_Disclaimer 3: concepts I talk about here will work for any website even if you are not using bot framework _</p>
<p><em>Disclaimer 4: sorry about all these disclaimers!</em> <em>&#x1f609;</em></p>
<h1 id="Adding-push-notification-to-an-existing-bot"><a href="#Adding-push-notification-to-an-existing-bot" class="headerlink" title="Adding push notification to an existing bot"></a><strong>Adding push notification to an existing bot</strong></h1><blockquote>
<p>You can try a live version of this sample here: <a href="https://webchatpush.azurewebsites.net/web/index.html" target="_blank" rel="noopener">https://webchatpush.azurewebsites.net/web/index.html</a></p>
</blockquote>
<p>The bot we are using in this sample is a really simple one. If you say anything to it, it will start sending one message every 5 seconds. You can stop it by saying “stop”.</p>
<p>You can have a look at the code doing this (<a href="https://github.com/meulta/webchat-pushnotifications/blob/master/bot.js#L84-L103" target="_blank" rel="noopener">https://github.com/meulta/webchat-pushnotifications/blob/master/bot.js#L84-L103</a>) but please do not take it as a reference to send messages proactively to a user from a bot. I tried to keep it as simple as possible as this is not the important part here. You can read more about how to send a message proactively to a user here: <a href="https://docs.botframework.com/en-us/azure-bot-service/templates/proactive/" target="_blank" rel="noopener">https://docs.botframework.com/en-us/azure-bot-service/templates/proactive/</a></p>
<p>This server code is responsible for creating VAPID keys and send push notification to clients.</p>
<ul>
<li><strong>Creating Vapid keys</strong></li>
</ul>
<p>If you create your server code in Node.js then you can use a very cool module created by Mozilla which will do almost all the work for you: web-push : <a href="https://github.com/web-push-libs/web-push" target="_blank" rel="noopener">https://github.com/web-push-libs/web-push</a></p>
<p>You will have to first generated Vapid keys using the <strong>webPush.generateVapidKeys()</strong> function. You only have to do this once or when you want to reset your keys. In our sample, we generate them and store them in a local JSON file. You might want to store this somewhere more secure.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vapidKeyFilePath = <span class="string">"./vapidKey.json"</span>;</span><br><span class="line"><span class="keyword">var</span> vapidKeys = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fs.existsSync(vapidKeyFilePath)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//if the vapid file exists, then we try to parse its content </span></span><br><span class="line">  <span class="comment">//to retrieve the public and private key</span></span><br><span class="line">  <span class="comment">//more tests might be necessary here</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    vapidKeys = <span class="built_in">JSON</span>.parse(fs.readFileSync(vapidKeyFilePath));</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">"There is an error with the vapid key file. Log: "</span> + e.message);</span><br><span class="line">    process.exit(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//if the file did not exists, we use the web-push module to create keys</span></span><br><span class="line">  <span class="comment">//and store them in the file for future use</span></span><br><span class="line">  <span class="comment">//you should copy the public key in the index.js file</span></span><br><span class="line"></span><br><span class="line">  vapidKeys = webPush.generateVAPIDKeys();</span><br><span class="line">  fs.writeFileSync(vapidKeyFilePath, <span class="built_in">JSON</span>.stringify(vapidKeys));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"No vapid key file found. One was generated. Here is the public key: "</span> + vapidKeys.publicKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You then have to call the <strong>setVapidDetails()</strong> function to configure the web push module to send push notifications using the vapid private key. This will ensure the push server to be sure it comes from you.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webPush.setVapidDetails(</span><br><span class="line">  <span class="string">'mailto:example@yourdomain.org'</span>,</span><br><span class="line">  vapidKeys.publicKey,</span><br><span class="line">  vapidKeys.privateKey);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Handling event to register push</strong></li>
</ul>
<p>A bot can receive messages from the user but it can also receive events from the client code. This is very handful to send data to your bot backend code without the user knowing it. In the web chat control it is called the backchannel.</p>
<p>We are going to use this backchannel for the client code to have a way of sending every user push subscription information. We just listen to incoming activities of type <strong>event</strong> and check that the message name is <strong>pushsubscriptionadded</strong> (which is one I totally imagine myself, you can pass whatever name you want).</p>
<p>Each time the bot receive a new push subscription, we store it in a local variable associating it to the user internal id in the bot. Note that it might be best to store it in the bot user data.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bot.on(<span class="string">"event"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (message.name === <span class="string">"pushsubscriptionadded"</span>) &#123;</span><br><span class="line">    pushPerUser[message.user.id] = message.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Catching messages going out and sending push notifications</strong></li>
</ul>
<p>In our current scenario, we want to send a push notification to the user each time there is a message sent by the bot. This can easily be done with an event called <strong>outgoing</strong>. You subscribe to this event then check to see if there is a push notification associated with the user the outgoing message is sent to. If we do, then we use the <strong>webPush.sendNotification()</strong> function from the web-push module. It will use the VAPID private key and the information from the push subscription to ask the appropriate web push server to send a notification to the browser. It knows which server to talk to thanks to the endpoint property we got from the client in the <strong>pushsubscriptionadded</strong> event call.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bot.on(<span class="string">"outgoing"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pushPerUser &amp;&amp; pushPerUser[message.address.user.id]) &#123;</span><br><span class="line">    <span class="keyword">var</span> pushsub = pushPerUser[message.address.user.id];</span><br><span class="line"></span><br><span class="line">    webPush.sendNotification(&#123;</span><br><span class="line">        endpoint: pushsub.endpoint,</span><br><span class="line">        TTL: <span class="string">"1"</span>,</span><br><span class="line">        keys: &#123;</span><br><span class="line">        p256dh: pushsub.key,</span><br><span class="line">        auth: pushsub.authSecret</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, message.text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="Setting-up-push-in-the-client"><a href="#Setting-up-push-in-the-client" class="headerlink" title="Setting up push in the client"></a><strong>Setting up push in the client</strong></h1><p>This is the most interesting part. The first role of the client code is to register the service worker in the browser. To do this, we use the <strong>navigator.serviceWorker.register()</strong> function by giving it the service worker file name. This function return a Promise so you can chain a <strong>.then()</strong> function to execute some code once the service worker is registered. If the service worker is already registered, it will return the current one.</p>
<p>In our case, we take this opportunity to try to get the existing push notification manager subscription using <strong>registration.pushManager.getSubscription()</strong> (where registration is the service worker instance). If it does not exist, we will just have to create and return a new one create using <strong>registration.pushManager.subscribe()</strong> giving it an <strong>applicationServerKey</strong>. This applicationServerKey is the public key your server generated.</p>
<p>The subscription object we get from this is containing everything the server will need to send a notification to the client: the endpoint, the key and a secret.</p>
<p>In the current sample, all this is done in the <strong>setupPush</strong> function which takes a callback as a parameter and calls it back with the subscription information.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setupPush = <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//first step is registering the service worker file</span></span><br><span class="line">  navigator.serviceWorker.register(<span class="string">'service-worker.js'</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">registration</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//once the sw is registered, we try to get an existing push subscription </span></span><br><span class="line">    <span class="keyword">return</span> registration.pushManager.getSubscription()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">subscription</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//if the subscription exists, then we pass is to the next chained .then function using return</span></span><br><span class="line">    <span class="keyword">if</span> (subscription) &#123;</span><br><span class="line">      <span class="keyword">return</span> subscription;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//if the subscription does not exists, we wrap the VAPID public key and create a new one</span></span><br><span class="line">  <span class="comment">//we pass this new once to the next chaind .then function using return</span></span><br><span class="line">  <span class="keyword">const</span> convertedVapidKey = urlBase64ToUint8Array(VAPID_PUBLICKEY);</span><br><span class="line">    <span class="keyword">return</span> registration.pushManager.subscribe(&#123;</span><br><span class="line">      userVisibleOnly: <span class="literal">true</span>,</span><br><span class="line">        applicationServerKey: convertedVapidKey</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">subscription</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//wrapping the key and secret</span></span><br><span class="line">  <span class="keyword">const</span> rawKey = subscription.getKey ? subscription.getKey(<span class="string">'p256dh'</span>) : <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">const</span> key = rawKey ? btoa(<span class="built_in">String</span>.fromCharCode.apply(<span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(rawKey))) : <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">const</span> rawAuthSecret = subscription.getKey ? subscription.getKey(<span class="string">'auth'</span>) : <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">const</span> authSecret = rawAuthSecret ? btoa(<span class="built_in">String</span>.fromCharCode.apply(<span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(rawAuthSecret))) : <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">const</span> endpoint = subscription.endpoint;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//we call back the code that asked to register push notification with the subscription information</span></span><br><span class="line"></span><br><span class="line">  done(&#123;</span><br><span class="line">    endpoint: subscription.endpoint,</span><br><span class="line">      key: key,</span><br><span class="line">      authSecret: authSecret</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This <strong>setupPush</strong> function is called right after we setup the Web Chat control. In the callback function we give to it, we use the Direct Line SDK to send an event of type <strong>pushsubscriptionadded</strong> to the bot, through the back channel.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setupPush(<span class="function">(<span class="params">subscriptionInfo</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//once push notifications are setup, we get the subscription info back in this callback</span></span><br><span class="line">  <span class="comment">//we use the backchannel to send this info back to the bot using an 'event’ activity</span></span><br><span class="line">  botConnection</span><br><span class="line">    .postActivity(&#123;</span><br><span class="line">      type: <span class="string">"event"</span>,</span><br><span class="line">      name: <span class="string">"pushsubscriptionadded"</span>,</span><br><span class="line">      value: subscriptionInfo,</span><br><span class="line">      <span class="keyword">from</span>: &#123; <span class="attr">id</span>: botConnection.conversationId &#125; <span class="comment">//you could define your own userId here</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//we store the conversation id which we get back from postActivity(…) in the LocalStorage</span></span><br><span class="line">    <span class="comment">//we will need this in case of conversation resuming</span></span><br><span class="line">    localStorage.setItem(<span class="string">"pushsample.botConnection.conversationId"</span>, botConnection.conversationId);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>As you can see in the code above, we also store the <strong>conversationid</strong> in the browser <strong>localStorage</strong> so it will persist. We need this to be able to resume the conversation when the user clicks on a notification after the tab was closed. We handle this by adding a get parameter to the webpage url: <strong>?isBack=y</strong>. To resume a conversation using Direct Line, you just have to give back the <strong>conversationid</strong> as we do here:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getParameterByName(<span class="string">"isback"</span>) === <span class="string">'y'</span>) &#123;</span><br><span class="line">  <span class="comment">//if we are resuming an existing conversation, we get back the conversationid from LocalStorage</span></span><br><span class="line">  botConnection = <span class="keyword">new</span> DirectLine.DirectLine(&#123;</span><br><span class="line">  secret: DIRECTLINE_SECRET,</span><br><span class="line">  conversationId: localStorage.getItem(<span class="string">"pushsample.botConnection.conversationId"</span>),</span><br><span class="line">  webSocket: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="Listening-to-push-notification-in-the-background-with-the-service-worker"><a href="#Listening-to-push-notification-in-the-background-with-the-service-worker" class="headerlink" title="Listening to push notification in the background with the service worker"></a><strong>Listening to push notification in the background with the service worker</strong></h1><p>Last but not least, we need to write the code that will sit in the browser and handle push notification event even if the website is not opened.</p>
<ul>
<li><strong>Registering to push</strong></li>
</ul>
<p>The first piece of code is the one handling the push events.  To do this we use the self.addEventListener() function. It takes an event name (here “push”) and a callback. Each time a new push notification is received, this callback is going to be called. Here, we just call <strong>registration.showNotification()</strong> which displays it using a nice image and some text. The payload variable is built using the event data (which is the notification text we send from the server).</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'push'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="comment">//creating the notification message (we should never be in the "no message” case)</span></span><br><span class="line"><span class="keyword">var</span> payload = event.data ? event.data.text() : <span class="string">'No message…'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//we show a notification to the user with the text message</span></span><br><span class="line"><span class="comment">//and an icon which is hosted as a resource on the website</span></span><br><span class="line">event.waitUntil(</span><br><span class="line">    self.registration.showNotification(<span class="string">'Chat bot!'</span>, &#123;</span><br><span class="line">      body: payload,</span><br><span class="line">      icon: <span class="string">'/web/img/thinking_morphi.png'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Handling click on notifications</strong></li>
</ul>
<p>By default, clicking on a browser notification does nothing. You can add a custom behavior using the ‘notificationclick’ event in the service worker code. Its code is pretty straightforward as we list all the clients (a tab being also seen as a client), we look if one is displaying our web page. If yes and the focus is on another one, we switch to it. If yes and the focus is on it, we do nothing. And finally, if no, we reopen the page adding the <strong>?isBack=y</strong> parameter.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'notificationclick'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Android doesn’t close the notification when you click on it </span></span><br><span class="line">  <span class="comment">// See: http://crbug.com/463146 </span></span><br><span class="line">  event.notification.close();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This looks to see if the current is already open and </span></span><br><span class="line">  <span class="comment">// focuses if it is </span></span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line"></span><br><span class="line">    <span class="comment">//searching for all clients / tab opened in the browser</span></span><br><span class="line">    clients.matchAll(&#123;</span><br><span class="line">      type: <span class="string">"window"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">clientList</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//going through the list of clients/tab and trying to find our website</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = ; i &lt; clientList.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> client = clientList[i];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//if we find it, we put focus back on the tab</span></span><br><span class="line">      <span class="keyword">if</span> ((client.url.toLowerCase() == baseurl + <span class="string">'/web/index.html'</span> || client.url.toLowerCase() == baseurl + <span class="string">'/web/index.html?isback=y'</span>) &amp;&amp; <span class="string">'focus'</span> <span class="keyword">in</span> client)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> client.focus();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (clients.openWindow) &#123;</span><br><span class="line">      <span class="comment">//if we did not find it, then we re-open it with the isback=y parameter</span></span><br><span class="line">      <span class="comment">//to ensure that we resume the conversation using the conversationid</span></span><br><span class="line">      <span class="keyword">return</span> clients.openWindow(<span class="string">'/web/index.html?isback=y'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="What’s-next"><a href="#What’s-next" class="headerlink" title="What’s next?"></a><strong>What’s next?</strong></h1><p>Using <strong>web push notifications</strong> in a web chat control is obvious. There are a lot of other cases in which it can be really helpful. It can help you notify someone about a trending news, an update on your website or a new friend connection.</p>
<p>Understanding how web notifications are working and adding them to one of your projects is a great first step. Implementing more PWAs’ features can be simpler than you think. At Microsoft, we have recently introduced <a href="http://preview.pwabuilder.com/generator" target="_blank" rel="noopener">PWA Builder</a>, which simplifies and automates building a manifest so it’s as easy as providing resources and a description for your app. It will also help you in the process of adding service workers features to your app, such as cache management. In a future version, it will certainly also help you create the service worker code needed to handle push notifications.</p>
<p>In a very near future, service workers will be available in <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/serviceworker/?q=service%20workers" target="_blank" rel="noopener">every modern browser</a>: <strong>take this opportunity and be part of the Progressive Web Apps world!</strong></p>
<blockquote>
<p>If you have any question about this blog article, feel free to contact me on twitter: <a href="https://twitter.com/meulta" target="_blank" rel="noopener">@meulta</a></p>
</blockquote>

                    
                        

                    
                    
                        <p>
                            <a href="/2017/04/17/bot-framework-web-chat-and-push-notifications/#post-footer" class="postShorten-excerpt_link link">
                                Comment and share
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
        <li class="pagination-number">page 1 of 1</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 Etienne Margraff. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpg" alt="Author&#39;s picture">
        
            <h4 id="about-card-name">Etienne Margraff</h4>
        
            <div id="about-card-bio"><p>I write code and love working with web, AR, VR and Spatial Computing</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>Software Engineering Lead</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                Seattle, WA
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-dbd16rvloemmuxdzniplmnxxvwoz24eya9wol0b7vvmlokgqsjivmb8dnscy.min.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
